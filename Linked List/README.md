1. Given a linked list, find and return the length of input LL. Do it iteratively.

2. Given a linked list and a position i, print the node at ith position.
If position i is greater than length of LL, then don't print anything.
Indexing starts from 0.

3. (Delete Node in LL) Given a linked list and a position i, delete the node of ith position from Linked List iteratively.
If position i is greater than length of LL, then you should return the same LL without any change.
Indexing starts from 0. You don't need to print the elements, just delete the node and return the head of updated LL.

4. (Find a node in LL) Given a linked list and an integer n you need to find and return index where n is present in the LL. Do this iteratively.
Return -1 if n is not present in the LL.
Indexing of nodes starts from 0.

5. (AppendLastNToFirst) Given a linked list and an integer n, append the last n elements of the LL to front.
Indexing starts from 0. You don't need to print the elements, just update the elements and return the head of updated LL.
Assume given n will be smaller than length of LL.

6. (Eliminate duplicates from LL) Given a sorted linked list (elements are sorted in ascending order). Eliminate duplicates from the given LL, such that output LL contains only unique elements.
You don't need to print the elements, just remove duplicates and return the head of updated LL.

7. (Print reverse LinkedList) Print a given linked list in reverse order. You need to print the tail first and head last. You canâ€™t change any pointer in the linked list, just print it in reverse order.

8. (Midpoint of Linked list) Given a linked list, find and return the midpoint.
If the length of linked list is even, return the first mid point.

9. (Merge two sorted LL) Given two linked lists sorted in increasing order. Merge them in such a way that the result list is also sorted (in increasing order).
Try solving with O(1) auxiliary space (in-place). You just need to return the head of new linked list, don't print the elements.

10. (Merge Sort) Sort a given linked list using Merge Sort.
You don't need to print the elements, just sort the elements and return the head of updated LL.

Constraints :
1 <= Length of LL <= 1000

11. Check if a given linked list is palindrome or not. Return true or false.
Indexing starts from 0.
Input format : Linked list elements (separated by space and terminated by -1)

12. (Reverse LL (Recursive)) Given a linked list, reverse it using recursion.
You don't need to print the elements, just reverse the LL duplicates and return the head of updated LL.
Input format : Linked list elements (separated by space and terminated by -1)`

13. (Reverse LL (Iterative)) Given a linked list, reverse it iteratively.
You don't need to print the elements, just reverse the LL duplicates and return the head of updated LL.

14. (Delete node (recursive)) Given a linked list and a position i, delete the node of ith position from Linked List recursively.
If position i is greater than length of LL, then you should return the same LL without any change.

15. (Find a node in LL (recursive)) Given a linked list and an integer n you need to find and return index where n is present in the LL. Do this recursively.
Return -1 if n is not present in the LL.

16. (Even after Odd LinkedList) Arrange elements in a given Linked List such that, all even numbers are placed after odd numbers. Respective order of elements should remain same.

17. (Delete every N nodes) Given a linked list and two integers M and N. Traverse the linked list such that you retain M nodes then delete next N nodes, continue the same until end of the linked list. That is, in the given linked list you need to delete N nodes after every M nodes.
